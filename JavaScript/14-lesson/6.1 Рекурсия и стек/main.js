'use strict'

//-----------------------------------------------------------------------------------------ЗАДАЧА 1
// Напишите функцию sumTo(n), которая вычисляет сумму чисел 1 + 2 + ... + n.

// Например:

// sumTo(1) = 1
// sumTo(2) = 2 + 1 = 3
// sumTo(3) = 3 + 2 + 1 = 6
// sumTo(4) = 4 + 3 + 2 + 1 = 10
// ...
// sumTo(100) = 100 + 99 + ... + 2 + 1 = 5050

// Пример работы вашей функции:

function sumTo(n) { /*... ваш код ... */ }

alert( sumTo(100) ); // 5050

// Сделайте три варианта решения:

// 1 С использованием цикла. Вот:

function sumTo(n) {
    let result = 0;
    for (let i = 1; i <= n; i++) {
        result += i;
    }
    return result;
}

// 2 Через рекурсию, т.к. sumTo(n) = n + sumTo(n-1) for n > 1. Вот:

function sumTo(n) {
  if (n === 1) {
      return 1;
  } else {
      return n + sumTo(n-1)
  }
}

// 3 С использованием формулы арифметической прогрессии. Вот:

// Формула прогрессии это вроде это - a(n) = a(1) + d ( n – 1 ) 
//получается n который мы в функцию передаем это 1 + (n-1)D
//только зачем мне эта информация

function sumTo(n) {
  
}

sumTo(4)


// P.S. Какой вариант решения самый быстрый? Самый медленный? Почему?

// P.P.S. Можно ли при помощи рекурсии посчитать sumTo(100000)?


//-----------------------------------------------------------------------------------------ЗАДАЧА 2

// Факториал натурального числа – это число, умноженное на "себя минус один", затем на "себя минус два", 
// и так далее до 1. Факториал n обозначается как n!

// Определение факториала можно записать как:

// n! = n * (n - 1) * (n - 2) * ...*1
// Примеры значений для разных n:

// 1! = 1
// 2! = 2 * 1 = 2
// 3! = 3 * 2 * 1 = 6
// 4! = 4 * 3 * 2 * 1 = 24
// 5! = 5 * 4 * 3 * 2 * 1 = 120
// Задача – написать функцию factorial(n), которая возвращает n!, используя рекурсию.

alert( factorial(5) ); // 120
// P.S. Подсказка: n! можно записать как n * (n-1)! Например: 3! = 3*2! = 3*2*1! = 6

//РЕШЕНИЕ

function factorial(n) {
    if (n === 1) {
        return 1;
    } else {
        return n * factorial(n-1);
    }
}

//-----------------------------------------------------------------------------------------ЗАДАЧА 3

// Последовательность чисел Фибоначчи определяется формулой Fn = Fn-1 + Fn-2. То есть, 
// следующее число получается как сумма двух предыдущих.

// Первые два числа равны 1, затем 2(1+1), затем 3(1+2), 5(2+3) и так далее: 1, 1, 2, 3, 5, 8, 13, 21....

// Числа Фибоначчи тесно связаны с золотым сечением и множеством природных явлений вокруг нас.

// Напишите функцию fib(n) которая возвращает n-е число Фибоначчи.

// Пример работы:
alert(fib(3)); // 2
alert(fib(7)); // 13
alert(fib(77)); // 5527939700884757
// P.S. Все запуски функций из примера выше должны работать быстро. Вызов fib(77) должен занимать не более доли секунды.

//решение (СНАЧАЛА БЕЗ РЕКУРСИИ) и вот оно работает БЫСТРО
function fib(n) {
    //допустим я буду склаыдывать весь ряд до n  в массив...
    let FibonacciArray = [1, 1];//тут вроде нет смысла считать

    //начнем ряд с 1, далее 1+1, 2+1, 3+2
    for (let i = 0; i < n; i++) {
        let x = FibonacciArray[i] + FibonacciArray[i+1]; 
        FibonacciArray.push(x);
    }

    return FibonacciArray[n-1];//т.к. в массиве индексы будут с 0 
}

//решение с рекурсией, работает медленно, на 77 зависает
function fib(n) {
    if (n === 0) {
        return 0;
    } else if (n === 1) {
        return 1;
    } else {
        return fib(n-1) + fib(n-2);
    }
    
}

//посмотрела учебник - в итоге правильно было через цикл, но другой, 
//но мне мой больше нравится, он проще.

//решение с адель
function getFib(n) {
  //базовый случай
  if (n === 1 || n === 0) {
    return 1;
  } 
  return (getFib(n-1) - getFib(n-2));
}

//-----------------------------------------------------------------------------------------ЗАДАЧА 4

// Допустим, у нас есть односвязный список (как описано в главе Рекурсия и стек):


// Напишите функцию printList(list), которая выводит элементы списка по одному.

// Сделайте два варианта решения: используя цикл и через рекурсию.

// Как лучше: с рекурсией или без?

let list = {
    value: 1,
    next: {
      value: 2,
      next: {
        value: 3,
        next: {
          value: 4,
          next: null
        }
      }
    }
  };

  //хочу выводить консоль логами, они не уточняли как

//РЕШЕНИЕ c рекурсией 

let list = {
    value: 1,
    next: {
      value: 2,
      next: {
        value: 3,
        next: {
          value: 4,
          next: null
        }
      }
    }
  };

function printList(list) {
    //конечная точка рекурсии это вызов последнего уровня
    if (list.next === null) {
        console.log(list.value)
    } else {
        console.log(list.value)
        return printList(list.next)
    }
    
}

printList(list)// 1, 2, 3, 4

//РЕШЕНИЕ без рекурсии

let list = {
    value: 1,
    next: {
      value: 2,
      next: {
        value: 3,
        next: {
          value: 4,
          next: null
        }
      }
    }
  };

function printList(list) {
    do {
        console.log(list.value)
        list = list.next;
    } while (list != null)
}

printList(list)// 1, 2, 3, 4

//какой лучше - оба нормально работают, но т.к. на циклы надо меньше ресурсов - 
//видимо, лучше цикл, будет там 100500 вложенных next и все зависнет

//-----------------------------------------------------------------------------------------ЗАДАЧА 5

// Вывод односвязного списка в обратном порядке
// важность: 5
// Выведите односвязный список из предыдущего задания Вывод односвязного списка в обратном порядке.

// Сделайте два решения: с использованием цикла и через рекурсию.

//РЕШЕНИЕ с рекурсией 
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};


function printListReverse(list) {


  if (list.next) {
    printListReverse(list.next);
    console.log(list.value)
  } else {//дошли до последнего - вывели value
    console.log(list.value)
  }

}
printListReverse(list)


//РЕШЕНИЕ без рекурсии 

let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printListReverse(list) {
  let values = [];
  while(list.next) {//спускаемся по уровням до последнего, сохраняя value
    values.push(list.value);
    list = list.next;
  }
  
  console.log(list.value);//выводим последний уровень 

  for (let i = 2; i >= 0; i -= 1) {//выводим предыдущие value в обратном порядке
    console.log(values[i])
  }

}

printListReverse(list)